/**
 * closeQuestionHandler.ts - Handles closing a quiz question, calculating scores,
 * emitting individual score updates, sending results, and locking further answers.
 */

import { Server, Socket } from 'socket.io';
import { CloseQuestionPayload } from '../types/socketTypes';
import { quizState } from '../quizState'; // This is QuizStateContainer
import { Question, QuizState, BackendQuizAnswer, BackendQuizParticipant } from '../types/quizTypes'; // Ensure Question is imported
import { calculateScore, ProcessedAnswerForScoring } from '../tournamentUtils/scoreUtils'; // Assuming scoreUtils is now shared or accessible
import { emitQuestionResults, QuestionResultsParams, QuizRoomName, TournamentRoomName } from '../sharedLiveLogic/emitQuestionResults';
import { emitParticipantScoreUpdate } from '../sharedLiveLogic/emitParticipantScoreUpdate';

import createLogger from '../../logger';
const logger = createLogger('CloseQuestionHandler');

// Helper to calculate ranks (similar to tournamentHelpers)
function calculateQuizRanks(participants: { [id: string]: BackendQuizParticipant }): Map<string, number> {
    const sortedParticipants = Object.values(participants).sort((a, b) => (b.score || 0) - (a.score || 0));
    const ranks = new Map<string, number>();
    let currentRank = 1;
    for (let i = 0; i < sortedParticipants.length; i++) {
        if (i > 0 && (sortedParticipants[i].score || 0) < (sortedParticipants[i - 1].score || 0)) {
            currentRank = i + 1;
        }
        ranks.set(sortedParticipants[i].id, currentRank);
    }
    return ranks;
}


function handleCloseQuestion(
    io: Server,
    socket: Socket, // Teacher's socket
    { quizId, questionUid }: CloseQuestionPayload
): void {
    logger.info(`[CloseQuestion] Received for quiz ${quizId}, question ${questionUid}`);

    const state: QuizState | undefined = quizState[quizId];
    if (!state) {
        logger.warn(`[CloseQuestion] No quiz state for ${quizId}`);
        socket.emit('quiz_action_response', {
            status: 'error',
            message: 'Erreur : état du quiz introuvable.'
        });
        return;
    }

    // Lock further answers for this question
    if (!state.lockedQuestions) state.lockedQuestions = {};
    state.lockedQuestions[questionUid] = true;
    state.currentQuestionUid = questionUid; // Ensure currentQuestionUid is set to the closed question

    const question = (state.questions || []).find(q => q.uid === questionUid);
    if (!question) {
        logger.error(`[CloseQuestion] Question UID ${questionUid} not found in quiz state ${quizId}.`);
        socket.emit('quiz_action_response', { status: 'error', message: 'Erreur : question introuvable.' });
        return;
    }

    const questionStartTime = state.questionStart || Date.now(); // Fallback, but should be set by setQuestionHandler
    if (!state.questionStart) {
        logger.warn(`[CloseQuestion] quizState[${quizId}].questionStart was not set. Timing might be inaccurate.`);
    }
    const totalQuestionsInQuiz = state.questions?.length || 1;


    // --- SCORE PROCESSING & INDIVIDUAL UPDATES ---
    if (state.participants && state.answers) {
        for (const participantId in state.participants) {
            const participant = state.participants[participantId];
            const rawAnswerStore = state.answers[participantId];
            const rawAnswerData = rawAnswerStore?.[questionUid]; // This is SharedQuizAnswerData-like

            let scoreForThisQuestion = 0;
            let processedValue: string | string[] | undefined = undefined;
            let timeTakenMs = (question.temps || 0) * 1000; // Default to max time if no answer
            let answerIsCorrect = false;
            let finalBaseScore = 0;
            let finalTimePenalty = (question.temps || 0) > 0 ? 500 : 0; // Max penalty if no answer

            let existingBackendAnswer: BackendQuizAnswer | undefined = rawAnswerStore?.[questionUid];


            if (rawAnswerData && question.reponses) {
                const clientTs = typeof rawAnswerData.clientTimestamp === 'number' ? rawAnswerData.clientTimestamp : questionStartTime;
                timeTakenMs = Math.max(0, clientTs - questionStartTime);
                
                let answerIndices: number | number[] | undefined = undefined;
                if (typeof rawAnswerData.answer === 'number' || Array.isArray(rawAnswerData.answer)) {
                    answerIndices = rawAnswerData.answer;
                } else if (typeof rawAnswerData.answer === 'string' && question.type === 'LIBRE') {
                    processedValue = rawAnswerData.answer;
                }

                let isCorrectForScoring = false;
                if (question.type === 'QCU' || (question.type === 'QCM' && question.reponses.filter(r => r.correct).length === 1)) {
                    const correctOptionIndex = question.reponses.findIndex(r => r.correct);
                    if (answerIndices === correctOptionIndex) {
                        isCorrectForScoring = true;
                    }
                    if (typeof answerIndices === 'number' && question.reponses[answerIndices]) {
                        processedValue = question.reponses[answerIndices].texte;
                    }
                } else if (question.type === 'QCM' && Array.isArray(answerIndices)) {
                     processedValue = answerIndices.map(idx => question.reponses?.[idx]?.texte).filter(t => !!t) as string[];
                }

                const processedAnswerForScoring: ProcessedAnswerForScoring = {
                    answerIdx: answerIndices,
                    clientTimestamp: clientTs,
                    serverReceiveTime: rawAnswerData.serverReceiveTime, // Corrected to use serverReceiveTime
                    isCorrect: isCorrectForScoring,
                    value: processedValue, 
                    timeMs: timeTakenMs,
                };

                const scoreResult = calculateScore(question, processedAnswerForScoring, totalQuestionsInQuiz);
                scoreForThisQuestion = scoreResult.normalizedQuestionScore;
                answerIsCorrect = scoreResult.scoreBeforePenalty > 0; 
                finalBaseScore = scoreResult.scoreBeforePenalty;
                finalTimePenalty = scoreResult.timePenalty;

                if (existingBackendAnswer) {
                    existingBackendAnswer.score = scoreForThisQuestion;
                    existingBackendAnswer.baseScore = finalBaseScore;
                    existingBackendAnswer.timePenalty = finalTimePenalty;
                    existingBackendAnswer.isCorrect = answerIsCorrect;
                    existingBackendAnswer.value = processedValue;
                    existingBackendAnswer.timeMs = timeTakenMs;
                    existingBackendAnswer.questionType = question.type;
                    // existingBackendAnswer.serverReceiveTime should have been set when rawAnswerData was created
                } else if (rawAnswerStore) { // Ensure rawAnswerStore exists before assigning
                     rawAnswerStore[questionUid] = {
                        questionUid: questionUid,
                        questionType: question.type,
                        answer: rawAnswerData.answer, 
                        clientTimestamp: rawAnswerData.clientTimestamp,
                        serverReceiveTime: rawAnswerData.serverReceiveTime, // Corrected to use serverReceiveTime
                        score: scoreForThisQuestion,
                        baseScore: finalBaseScore,
                        timePenalty: finalTimePenalty,
                        isCorrect: answerIsCorrect,
                        value: processedValue,
                        timeMs: timeTakenMs,
                    };
                } else { // Should not happen if state.answers[participantId] was initialized
                    logger.error(`[CloseQuestion] rawAnswerStore for participant ${participantId} is undefined. Cannot store scored answer.`);
                }

            } else { // No answer from participant for this question
                logger.debug(`[CloseQuestion] No answer for participant ${participantId} on Q ${questionUid}. Score: 0`);
                 if (existingBackendAnswer) {
                    existingBackendAnswer.score = 0;
                    existingBackendAnswer.baseScore = 0;
                    existingBackendAnswer.timePenalty = finalTimePenalty;
                    existingBackendAnswer.isCorrect = false;
                    existingBackendAnswer.value = "Pas de réponse";
                    existingBackendAnswer.timeMs = timeTakenMs;
                    existingBackendAnswer.questionType = question.type;
                } else if(rawAnswerStore) {
                     rawAnswerStore[questionUid] = {
                        questionUid: questionUid,
                        questionType: question.type,
                        answer: undefined,
                        clientTimestamp: questionStartTime, // Or Date.now() if no questionStartTime
                        serverReceiveTime: Date.now(),
                        score: 0,
                        baseScore: 0,
                        timePenalty: finalTimePenalty,
                        isCorrect: false,
                        value: "Pas de réponse",
                        timeMs: timeTakenMs,
                    };
                }
            }

            // Update participant's total score
            let newTotalScore = 0;
            for (const qUid in rawAnswerStore) {
                newTotalScore += rawAnswerStore[qUid]?.score || 0;
            }
            participant.score = newTotalScore;
        }
    } else {
        logger.warn(`[CloseQuestion] No participants or answers structure in quizState for ${quizId}. Skipping score calculation.`);
    }

    // --- CALCULATE RANKS & EMIT INDIVIDUAL SCORE UPDATES ---
    const ranks = calculateQuizRanks(state.participants || {});
    if (state.participants) {
        for (const participantId in state.participants) {
            const participant = state.participants[participantId];
            const participantSocketId = Object.keys(state.socketToJoueur || {}).find(
                sId => state.socketToJoueur?.[sId] === participant.id
            );

            if (participantSocketId) {
                const targetSocket = io.sockets.sockets.get(participantSocketId);
                if (targetSocket) {
                    const rank = ranks.get(participant.id) || 0;
                    emitParticipantScoreUpdate(targetSocket, {
                        newTotalScore: participant.score || 0,
                        currentRank: rank
                    });
                } else {
                     logger.warn(`[CloseQuestion] Socket instance NOT FOUND for socket ID ${participantSocketId} (participant ${participant.id})`);
                }
            } else {
                 logger.warn(`[CloseQuestion] Socket ID NOT FOUND for participant ${participant.id} to emit score update.`);
            }
        }
    }

    // --- PREPARE AND EMIT LEADERBOARD ---
    let leaderboardForEmission = Object.values(state.participants || {})
        .map(p => ({ id: p.id, name: p.name || 'Anonymous', score: p.score || 0, rank: ranks.get(p.id) || 0 }))
        .sort((a, b) => (a.rank || 0) - (b.rank || 0));


    // --- EMIT QUESTION_RESULTS (Correct Answers) ---
    const correctAnswersText = question.reponses
        ? (question.reponses || []).filter(r => r.correct).map(r => r.texte)
        : [];
    
    // For students in the linked tournament (if any)
    const tournamentCode = state.tournament_code;
    if (tournamentCode) {
        const tournamentRoomName: TournamentRoomName = `live_${tournamentCode}`;
        emitQuestionResults(io, tournamentRoomName, {
            questionUid,
            correctAnswers: correctAnswersText,
            leaderboard: leaderboardForEmission
        });
    }
    
    // For the projector view
    const projectorRoomName: QuizRoomName = `quiz_projector_${quizId}`;
    emitQuestionResults(io, projectorRoomName, {
        questionUid,
        correctAnswers: correctAnswersText,
        leaderboard: leaderboardForEmission
    });

    // --- PREPARE AND EMIT OLD-STYLE RESULTS FOR COMPATIBILITY ---
    const correctAnswersIndices = question.reponses
        ? (question.reponses || []).map((r, idx) => r.correct ? idx : null).filter(idx => idx !== null) as number[]
        : [];
        
    let leaderboardForProjector: { id: string; username: string; score: number; avatar?: string }[] = [];
    if (state.participants) {
        leaderboardForProjector = Object.values(state.participants).map(p => ({
            id: p.id,
            username: p.name || p.id, // Use name, fallback to id
            score: p.score || 0,
            // avatar: p.avatar // If avatar is part of BackendQuizParticipant
        })).sort((a, b) => b.score - a.score);
    }
    const playerCount = leaderboardForProjector.length;

    // Send to projector room (full leaderboard + player count + correct answers)
    io.to(`quiz_projector_${quizId}`).emit('quiz_question_results', {
        leaderboard: leaderboardForProjector,
        correctAnswers: correctAnswersIndices,
        playerCount,
    });
    
    // Send to teacher dashboard (similar data)
    // The 'quiz_action_response' is for the close action itself.
    socket.emit('quiz_action_response', { // Emitting to the triggering teacher's socket
        status: 'success',
        message: 'Question fermée et résultats calculés.',
        // Optionally include results summary for teacher here
        // results: { playerCount, questionUid } 
    });

    // Emit quiz_question_closed to relevant rooms (students, projector)
    // This event signals that no more answers are accepted and results are available.
    const questionClosedPayload = {
        questionUid,
        correctAnswers: correctAnswersIndices,
        // Leaderboard might be too large for this event, clients can use participant_score_update
        // and projector has its own quiz_question_results.
    };
    if (tournamentCode) {
        io.to(`live_${tournamentCode}`).emit('quiz_question_closed', questionClosedPayload);
    }
    io.to(`quiz_projector_${quizId}`).emit('quiz_question_closed', questionClosedPayload);


    logger.info(`[CloseQuestion] Results sent for quiz ${quizId}, question ${questionUid}`);
}

export default handleCloseQuestion;
