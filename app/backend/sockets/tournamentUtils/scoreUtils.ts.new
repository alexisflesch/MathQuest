// filepath: /home/aflesch/mathquest/app/sockets/tournamentUtils/scoreUtils.ts
/**
 * scoreUtils.ts - Utility functions for score calculations
 * 
 * This module provides functions for calculating tournament scores
 * based on answer correctness, timing, and other factors.
 */

import { TournamentState, TournamentAnswer } from '../types/tournamentTypes';
import { Question } from '../types/quizTypes';

const createLogger = require('../../logger');
const logger = createLogger('ScoreUtils');

/**
 * Interface for score calculation result
 */
export interface ScoreResult {
  baseScore: number;
  timePenalty: number;
  totalScore: number;
}

/**
 * Calculate the score for a given question and answer.
 * @param question - The question object.
 * @param answer - The answer object.
 * @param questionStartTime - The timestamp when the question started.
 * @param totalQuestions - The total number of questions in the tournament.
 * @returns An object containing baseScore, timePenalty, and totalScore.
 */
export function calculateScore(
  question: Question | null | undefined,
  answer: TournamentAnswer | null | undefined,
  questionStartTime: number,
  totalQuestions: number
): ScoreResult {
    logger.debug(`[calculateScore] Inputs: question=${JSON.stringify(question)}, answer=${JSON.stringify(answer)}, questionStartTime=${questionStartTime}, totalQuestions=${totalQuestions}`);

    if (!question || !answer || !Array.isArray(question.reponses)) {
        logger.warn(`[calculateScore] Invalid inputs: question=${JSON.stringify(question)}, answer=${JSON.stringify(answer)}`);
        return { baseScore: 0, timePenalty: 0, totalScore: 0 };
    }

    if (!answer) {
        logger.warn(`[calculateScore] Missing answer object for question=${question?.uid}`);
        return { baseScore: 0, timePenalty: 0, totalScore: 0 };
    }

    if (answer.answerIdx === undefined || (Array.isArray(answer.answerIdx) && answer.answerIdx.some((idx: number) => idx >= question.reponses!.length))) {
        logger.warn(`[calculateScore] Invalid answer index: answerIdx=${JSON.stringify(answer.answerIdx)}, question.reponses=${JSON.stringify(question.reponses)}`);
        return { baseScore: 0, timePenalty: 0, totalScore: 0 };
    }

    if (!totalQuestions || typeof totalQuestions !== 'number' || totalQuestions <= 0) {
        logger.warn(`[calculateScore] Invalid totalQuestions: ${totalQuestions}`);
        return { baseScore: 0, timePenalty: 0, totalScore: 0 };
    }

    let baseScore = 0, timePenalty = 0, totalScore = 0;
    const maxScorePerQuestion = 1000 / totalQuestions; // Maximum score per question

    if (answer) {
        if (question.type === 'choix_multiple') {
            const selected = Array.isArray(answer.answerIdx) ? answer.answerIdx : [answer.answerIdx];
            let good = 0, bad = 0, totalGood = 0;
            question.reponses!.forEach((rep: any, idx: number) => {
                if (rep.correct) totalGood++;
                if (selected.includes(idx)) {
                    if (rep.correct) good++;
                    else bad++;
                }
            });
            let raw = maxScorePerQuestion * good - maxScorePerQuestion * bad;
            let maxRaw = maxScorePerQuestion * totalGood;
            let ratio = maxRaw > 0 ? Math.max(0, raw) / maxRaw : 0;
            baseScore = maxScorePerQuestion * ratio; // Proportional to correct - incorrect
        } else if (question.type === 'choix_simple' || question.type === 'texte') {
            // Simple choice or text - is this index the correct one?
            const answerIdxVal = Array.isArray(answer.answerIdx) ? answer.answerIdx[0] : answer.answerIdx;
            if (answerIdxVal !== undefined && answerIdxVal >= 0 && answerIdxVal < question.reponses!.length) {
                if (question.reponses![answerIdxVal].correct) {
                    baseScore = maxScorePerQuestion; // Fully correct
                }
            } else {
                logger.warn(`[calculateScore] Invalid answer index: ${answerIdxVal} for question ${question.uid}`);
            }
        } else {
            logger.warn(`[calculateScore] Unknown question type: ${question.type}`);
        }
    }

    // Apply time penalty: Less time = less penalty
    const now = answer?.timestamp || Date.now();
    const elapsedTime = now - questionStartTime;
    const totalQuestionTime = question?.temps || 20; // Default 20 seconds if not specified
    const timeRatio = Math.min(1, Math.max(0, elapsedTime / 1000 / totalQuestionTime));
    
    // Quadratic penalty makes answering fast much more rewarding
    timePenalty = baseScore * timeRatio * timeRatio;
    
    // Calculate final score
    totalScore = baseScore - timePenalty;
    
    logger.debug(`[calculateScore] Result: baseScore=${baseScore}, timePenalty=${timePenalty}, totalScore=${totalScore}`);
    return { baseScore, timePenalty, totalScore };
}

/**
 * Generate a score summary for display.
 * @param baseScore - Base score for correctness.
 * @param timePenalty - Time penalty applied.
 * @param totalScore - Total final score.
 * @returns A friendly string describing the score.
 */
export function getScoreSummary(baseScore: number, timePenalty: number, totalScore: number): string {
    // Round to 1 decimal place for display
    const baseDisplay = Math.round(baseScore * 10) / 10;
    const penaltyDisplay = Math.round(timePenalty * 10) / 10;
    const totalDisplay = Math.round(totalScore * 10) / 10;
    
    return `Score: ${baseDisplay} - ${penaltyDisplay} (temps) = ${totalDisplay}`;
}

/**
 * Calculate total score for a participant based on all answers.
 * @param answers - Array of participant answers
 * @returns Total summed score
 */
export function calculateTotalScore(answers: TournamentAnswer[]): number {
    if (!answers || !Array.isArray(answers)) return 0;
    return answers.reduce((total, answer) => total + (answer.score || 0), 0);
}

/**
 * Save a participant's score to the database
 * @param prisma - The Prisma client instance
 * @param tournoiId - The ID of the tournament
 * @param participant - The participant object with score
 */
export async function saveParticipantScore(
  prisma: any, 
  tournoiId: string, 
  participant: { id: string; score: number; }
): Promise<void> {
    if (!participant.id || participant.id.startsWith('socket_')) {
        logger.warn(`[saveParticipantScore] Not saving score for non-persistent participant: ${participant.id}`);
        return;
    }
    
    // Check for invalid scores (NaN, undefined, Infinity)
    if (isNaN(participant.score) || participant.score === undefined || !isFinite(participant.score)) {
        logger.error(`[saveParticipantScore] Invalid score ${participant.score} for joueurId=${participant.id}. Setting to 0.`);
        participant.score = 0;
    }
    
    // Convert score to integer before saving to database
    participant.score = Math.round(participant.score);
    logger.info(`[saveParticipantScore] Saving score for tournoiId=${tournoiId}, joueurId=${participant.id}, score=${participant.score}`);
    logger.debug(`[saveParticipantScore] Received score=${participant.score} for joueurId=${participant.id}`);
    
    // Find the tournament
    const tournoi = await prisma.tournoi.findUnique({ where: { id: tournoiId } });
    if (!tournoi) {
        logger.error(`[saveParticipantScore] Tournoi with id=${tournoiId} does not exist. Skipping score creation for joueurId=${participant.id}`);
        return;
    }
    
    const tournoiIdUUID = tournoi.id;
    
    const joueurExists = await prisma.joueur.findUnique({ where: { id: participant.id } });
    if (!joueurExists) {
        logger.error(`[saveParticipantScore] Joueur with id=${participant.id} does not exist. Skipping score creation for tournoiId=${tournoiIdUUID}`);
        return;
    }
    
    logger.debug(`[saveParticipantScore] Validated existence of Tournoi (id=${tournoiIdUUID}) and Joueur (id=${participant.id})`);
    
    const existing = await prisma.score.findFirst({ 
        where: { 
            tournoi: { id: tournoiIdUUID }, 
            joueur: { id: participant.id } 
        } 
    });
    
    // Ensure the score is a valid integer before saving to database
    const scoreInt = Math.max(0, Math.min(1000, Math.round(participant.score || 0))); // Clamp score between 0 and 1000
    
    try {
        if (existing) {
            logger.info(`[saveParticipantScore] Updating existing score record id=${existing.id} with score=${scoreInt}`);
            await prisma.score.update({
                where: { id: existing.id },
                data: {
                    score: scoreInt, // Use the integer score
                }
            });
        } else {
            logger.info(`[saveParticipantScore] Creating new score record for tournoiId=${tournoiIdUUID}, joueurId=${participant.id}, score=${scoreInt}`);
            await prisma.score.create({
                data: {
                    score: scoreInt, // Use the integer score
                    tournoi: {
                        connect: {
                            id: tournoiIdUUID,
                        }
                    },
                    joueur: {
                        connect: {
                            id: participant.id,
                        }
                    }
                }
            });
        }
        logger.info(`[saveParticipantScore] Successfully saved score for joueurId=${participant.id}, tournoiId=${tournoiIdUUID}`);
    } catch (error) {
        logger.error(`[saveParticipantScore] Error saving score: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Scale scores for quiz - placeholder function for backwards compatibility
 * This function was removed in the original implementation but maintained for API compatibility
 */
export function scaleScoresForQuiz(): void {
    // Function intentionally left empty as it was removed from the original implementation
    // Keeping it for backward compatibility
    logger.warn('[scaleScoresForQuiz] This function is deprecated and does nothing');
}

// Create the default export object with all the functions
const defaultExport = {
    calculateScore,
    getScoreSummary,
    calculateTotalScore,
    saveParticipantScore,
    scaleScoresForQuiz
};

export default defaultExport;

// For CommonJS compatibility
// This makes the functions available both as named exports and as properties of the module.exports object
if (typeof module !== 'undefined') {
    Object.assign(module.exports, defaultExport);
    // @ts-ignore - TypeScript doesn't like this but it's needed for CommonJS compatibility
    module.exports.default = defaultExport;
}
